# Schema Redesign: Canonical Sources and Derived Fields

**Date:** 2025-11-28  
**Status:** Proposal  
**Goal:** Clear data ownership, optimized queries, easy regeneration

---

## Problem Statement

The current schema has **bidirectional ID arrays** that must stay in sync:

```
concepts.catalog_ids  ↔  catalog.concept_ids
concepts.chunk_ids    ↔  chunks.concept_ids
```

This creates maintenance complexity:
1. When concepts are extracted, both sides must be updated
2. If one side gets out of sync, queries return inconsistent results
3. No clear "source of truth" for regeneration

---

## Design Principles

### 1. **IDs for Truth, Names for Queries**

```
┌─────────────────────────────────────────────────────────────────────────┐
│  IDs (concept_ids, catalog_ids, etc.)    →  SOURCE OF TRUTH            │
│  Names (concept_names, catalog_titles)   →  PRIMARY FOR QUERIES        │
└─────────────────────────────────────────────────────────────────────────┘
```

**Runtime queries use TEXT arrays** (fast, human-readable, no cache lookups):
```typescript
// GOOD: Query on denormalized names
chunks.query().where(`array_contains(concept_names, 'dependency injection')`)
concepts.query().where(`array_contains(catalog_titles, 'Clean Architecture')`)

// AVOID: Resolving IDs at query time
const id = ConceptIdCache.getId('dependency injection');  // Don't do this
chunks.query().where(`array_contains(concept_ids, ${id})`)
```

**IDs are used for**:
- Regenerating derived fields
- Foreign key integrity
- Database updates and migrations
- Cross-table joins when needed

### 2. **Canonical Source → Derived Fields**

Every piece of data has exactly ONE canonical source. All other representations are **derived** and can be regenerated.

```
┌─────────────────────────────────────────────────────────────┐
│                     CANONICAL SOURCES                        │
├─────────────────────────────────────────────────────────────┤
│  concepts.name        → The concept itself (LLM-extracted)  │
│  concepts.id          → Hash of name (deterministic)        │
│  catalog.concept_ids  → Which concepts appear in document   │
│  chunks.concept_ids   → Which concepts appear in chunk      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     DERIVED FIELDS                          │
│              (regenerated from canonical sources)            │
├─────────────────────────────────────────────────────────────┤
│  concepts.catalog_ids  → Inverted index: which docs have C  │
│  concepts.chunk_ids    → Inverted index: which chunks have C │
│  concepts.adjacent_ids → Co-occurrence from same documents  │
│  concepts.related_ids  → Lexical matching on names          │
│  chunks.concept_density→ count(concept_ids) / text_length   │
└─────────────────────────────────────────────────────────────┘
```

### 2. **Forward References Are Canonical**

The document/chunk **OWNS** its concept references:

```typescript
// CANONICAL: Document says "I contain these concepts"
catalog.concept_ids = [conceptA, conceptB, conceptC]

// CANONICAL: Chunk says "I contain these concepts"
chunks.concept_ids = [conceptA, conceptB]

// DERIVED: Concept learns "I appear in these documents/chunks"
concepts.catalog_ids = /* regenerated by scanning catalog */
concepts.chunk_ids = /* regenerated by scanning chunks */
```

### 3. **LLM is Source of Concept Names**

```
LLM extracts concepts → concepts table (name is canonical)
                      → catalog.concept_ids (forward ref)
                      → chunks.concept_ids (forward ref)
```

The `concepts` table holds:
- `id` (hash of name - deterministic)
- `name` (LLM-extracted, canonical)
- `summary` (LLM-generated)
- WordNet enrichment (`synonyms`, `broader_terms`, `narrower_terms`)

---

## Proposed Schema Changes

### Current vs Proposed

| Field | Current | Proposed | Notes |
|-------|---------|----------|-------|
| `concepts.catalog_ids` | Canonical | **Derived** | Regenerate from `catalog.concept_ids` |
| `concepts.chunk_ids` | Canonical | **Derived** | Regenerate from `chunks.concept_ids` |
| `concepts.adjacent_ids` | Derived | Derived | No change |
| `concepts.related_ids` | Derived | Derived | No change |
| `catalog.concept_ids` | Canonical | **Canonical** | Forward reference (owns relationship) |
| `catalog.concept_names` | ❌ N/A | **Derived** | NEW: Text array for display & search |
| `chunks.concept_ids` | Canonical | **Canonical** | Forward reference (owns relationship) |
| `chunks.concept_names` | ❌ N/A | **Derived** | NEW: Text array for display & search |

### Schema Diagram

```
┌───────────────────────────────────────────────────────────────────────────┐
│                              CATALOG                                       │
│  ┌────────────────────────────────────────────────────────────────────┐   │
│  │  id              number     (hash of source)                       │   │
│  │  source          string     (file path)                            │   │
│  │  concept_ids     number[]   ← CANONICAL: concepts in this doc      │   │
│  │  concept_names   string[]   ← DERIVED: for display & text search   │   │
│  │  category_ids    number[]   ← CANONICAL: categories for this doc   │   │
│  │  ...                                                               │   │
│  └────────────────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────────────────┘
          │
          │ catalog_id (foreign key)
          ▼
┌───────────────────────────────────────────────────────────────────────────┐
│                              CHUNKS                                        │
│  ┌────────────────────────────────────────────────────────────────────┐   │
│  │  id              number     (hash of source+index)                 │   │
│  │  catalog_id      number     (→ catalog.id)                         │   │
│  │  concept_ids     number[]   ← CANONICAL: concepts in this chunk    │   │
│  │  concept_names   string[]   ← DERIVED: for display & text search   │   │
│  │  concept_density number     ← DERIVED: len(concept_ids)/text_len   │   │
│  │  ...                                                               │   │
│  └────────────────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────────────────┘
          │
          │ concept_ids[] point to →
          ▼
┌───────────────────────────────────────────────────────────────────────────┐
│                              CONCEPTS                                      │
│  ┌────────────────────────────────────────────────────────────────────┐   │
│  │  id              number     ← CANONICAL: hash of name              │   │
│  │  name            string     ← CANONICAL: LLM-extracted             │   │
│  │  summary         string     ← CANONICAL: LLM-generated             │   │
│  │  catalog_ids     number[]   ← DERIVED: scan catalog.concept_ids    │   │
│  │  catalog_titles  string[]   ← DERIVED: lookup catalog.source       │   │
│  │  chunk_ids       number[]   ← DERIVED: scan chunks.concept_ids     │   │
│  │  adjacent_ids    number[]   ← DERIVED: co-occurrence               │   │
│  │  related_ids     number[]   ← DERIVED: lexical matching            │   │
│  │  synonyms        string[]   ← ENRICHED: WordNet                    │   │
│  │  broader_terms   string[]   ← ENRICHED: WordNet                    │   │
│  │  narrower_terms  string[]   ← ENRICHED: WordNet                    │   │
│  │  weight          number     ← DERIVED: frequency-based             │   │
│  │  vector          Float32[]  ← DERIVED: embedding of name           │   │
│  └────────────────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────────────────┘
```

---

## Regeneration Scripts

With this design, derived fields can be regenerated independently:

### 1. Rebuild `concepts.catalog_ids`

```typescript
// scripts/rebuild_concept_catalog_ids.ts
async function rebuildCatalogIds(db: Database) {
  const catalog = await db.openTable('catalog');
  const concepts = await db.openTable('concepts');
  
  // Build inverted index: concept_id → catalog_ids[]
  const conceptToCatalogs = new Map<number, number[]>();
  
  for await (const doc of catalog.query().select(['id', 'concept_ids'])) {
    for (const conceptId of doc.concept_ids) {
      if (!conceptToCatalogs.has(conceptId)) {
        conceptToCatalogs.set(conceptId, []);
      }
      conceptToCatalogs.get(conceptId)!.push(doc.id);
    }
  }
  
  // Update concepts table
  for (const [conceptId, catalogIds] of conceptToCatalogs) {
    await concepts.update()
      .where(`id = ${conceptId}`)
      .set({ catalog_ids: catalogIds });
  }
}
```

### 2. Rebuild `concepts.chunk_ids`

```typescript
// scripts/rebuild_concept_chunk_ids.ts
async function rebuildChunkIds(db: Database) {
  const chunks = await db.openTable('chunks');
  const concepts = await db.openTable('concepts');
  
  // Build inverted index: concept_id → chunk_ids[]
  const conceptToChunks = new Map<number, number[]>();
  
  for await (const chunk of chunks.query().select(['id', 'concept_ids'])) {
    for (const conceptId of chunk.concept_ids) {
      if (!conceptToChunks.has(conceptId)) {
        conceptToChunks.set(conceptId, []);
      }
      conceptToChunks.get(conceptId)!.push(chunk.id);
    }
  }
  
  // Update concepts table
  for (const [conceptId, chunkIds] of conceptToChunks) {
    await concepts.update()
      .where(`id = ${conceptId}`)
      .set({ chunk_ids: chunkIds });
  }
}
```

### 3. Rebuild All Derived Fields

```bash
# Full regeneration after re-seeding
npx tsx scripts/rebuild_derived_fields.ts ~/.concept_rag

# This runs:
# 1. rebuild_concept_catalog_ids
# 2. rebuild_concept_chunk_ids  
# 3. rebuild_adjacent_ids (co-occurrence)
# 4. rebuild_related_ids (lexical)
# 5. rebuild_concept_weights
# 6. rebuild_chunk_densities
```

---

## Query Optimization

### Fast Queries (use forward refs)

```typescript
// "What concepts are in this document?" - O(1)
const doc = await catalog.query().where(`id = ${catalogId}`).first();
const conceptIds = doc.concept_ids;

// "What concepts are in this chunk?" - O(1)
const chunk = await chunks.query().where(`id = ${chunkId}`).first();
const conceptIds = chunk.concept_ids;
```

### Index-Assisted Queries (use derived fields)

```typescript
// "Which documents have this concept?" - Uses concepts.catalog_ids
const concept = await concepts.query().where(`id = ${conceptId}`).first();
const catalogIds = concept.catalog_ids;

// "Which chunks have this concept?" - Uses concepts.chunk_ids
const chunkIds = concept.chunk_ids;
```

### Alternative: LanceDB Array Contains (slower but always consistent)

```typescript
// No derived fields needed - direct query
const docs = await catalog.query()
  .where(`array_contains(concept_ids, ${conceptId})`)
  .toArray();
```

**Trade-off:**
- Derived fields: Fast (O(1)), but need regeneration
- `array_contains`: Slower (table scan), but always consistent

---

## Seeding Flow

```
┌────────────────────────────────────────────────────────────────────┐
│                    SEEDING PIPELINE                                 │
└────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────────┐
│ 1. LOAD DOCUMENT                                                   │
│    - Extract text from PDF/EPUB                                    │
│    - Generate document hash                                        │
└────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────────┐
│ 2. LLM CONCEPT EXTRACTION                                          │
│    - Send document text to LLM                                     │
│    - Receive: primary_concepts[], categories[]                     │
│    - For each concept: get_or_create in concepts table             │
│    - Store concept_ids[] in catalog record                         │
└────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────────┐
│ 3. CHUNKING                                                        │
│    - Split document into chunks                                    │
│    - For each chunk:                                               │
│      - Match document concepts to chunk text (fuzzy or semantic)   │
│      - Store concept_ids[] in chunk record                         │
└────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────────┐
│ 4. POST-PROCESSING (derived field regeneration)                    │
│    - Rebuild concepts.catalog_ids (inverted index)                 │
│    - Rebuild concepts.chunk_ids (inverted index)                   │
│    - Rebuild adjacent_ids (co-occurrence)                          │
│    - Rebuild related_ids (lexical)                                 │
│    - Rebuild concept weights                                       │
│    - Rebuild chunk concept_density                                 │
└────────────────────────────────────────────────────────────────────┘
```

---

## Benefits

1. **Clear ownership**: Documents/chunks OWN their concept refs
2. **Easy regeneration**: Derived fields rebuilt from canonical sources
3. **Debuggable**: Can verify derived fields match canonical sources
4. **Incremental updates**: Add new document → update only its concept_ids → regenerate only affected derived fields
5. **Query flexibility**: Use derived fields for speed, or `array_contains` for guaranteed consistency

---

## Migration Path

1. **No schema changes required** - current schema already supports this model
2. **Code changes**:
   - Mark derived fields in documentation
   - Create regeneration scripts
   - Update seeding to populate forward refs first, derived fields after
3. **Validation script** to verify derived fields match canonical sources

---

## Denormalized Name Arrays (Recommended)

### The Pattern: IDs + Names

Store **both** concept IDs (canonical) and concept names (derived) in catalog and chunks:

```typescript
// catalog record
{
  concept_ids: [123, 456, 789],           // CANONICAL - foreign keys
  concept_names: ["clean architecture",    // DERIVED - for display & search
                  "dependency injection", 
                  "SOLID principles"]
}

// chunk record  
{
  concept_ids: [123, 456],                // CANONICAL - foreign keys
  concept_names: ["clean architecture",   // DERIVED - for display & search
                  "dependency injection"]
}
```

### Benefits

| Benefit | Description |
|---------|-------------|
| **No cache dependency** | Display concept names without `ConceptIdCache` lookup |
| **Text search** | BM25/full-text search on concept names directly |
| **Self-describing** | Chunk record is human-readable without joins |
| **Query flexibility** | `WHERE concept_names LIKE '%strategy%'` |
| **Debugging** | Can inspect data without resolving IDs |

### Regeneration

Names are **derived** from IDs, so regeneration is straightforward:

```typescript
// scripts/rebuild_concept_names.ts
async function rebuildConceptNames(db: Database) {
  const concepts = await db.openTable('concepts');
  const catalog = await db.openTable('catalog');
  const chunks = await db.openTable('chunks');
  
  // Build ID → name lookup
  const idToName = new Map<number, string>();
  for await (const c of concepts.query().select(['id', 'name'])) {
    idToName.set(c.id, c.name);
  }
  
  // Rebuild catalog.concept_names
  for await (const doc of catalog.query().select(['id', 'concept_ids'])) {
    const names = doc.concept_ids
      .map(id => idToName.get(id))
      .filter(Boolean);
    await catalog.update()
      .where(`id = ${doc.id}`)
      .set({ concept_names: names });
  }
  
  // Rebuild chunks.concept_names
  for await (const chunk of chunks.query().select(['id', 'concept_ids'])) {
    const names = chunk.concept_ids
      .map(id => idToName.get(id))
      .filter(Boolean);
    await chunks.update()
      .where(`id = ${chunk.id}`)
      .set({ concept_names: names });
  }
}
```

### Schema Update

```
┌───────────────────────────────────────────────────────────────────────────┐
│                              CATALOG                                       │
│  ┌────────────────────────────────────────────────────────────────────┐   │
│  │  concept_ids     number[]   ← CANONICAL: foreign keys to concepts  │   │
│  │  concept_names   string[]   ← DERIVED: for display & text search   │   │
│  └────────────────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│                              CHUNKS                                        │
│  ┌────────────────────────────────────────────────────────────────────┐   │
│  │  concept_ids     number[]   ← CANONICAL: foreign keys to concepts  │   │
│  │  concept_names   string[]   ← DERIVED: for display & text search   │   │
│  └────────────────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────────────────┘
```

### Query Examples

```typescript
// Text search across concept names (no cache needed)
const chunks = await chunksTable.query()
  .where(`array_contains(concept_names, 'dependency injection')`)
  .toArray();

// Partial matching
const docs = await catalogTable.query()
  .where(`concept_names LIKE '%strategy%'`)
  .toArray();

// Display without lookup
for (const chunk of chunks) {
  console.log(`Concepts: ${chunk.concept_names.join(', ')}`);
}
```

### Storage Trade-off

For 471K chunks with avg 3-5 concepts per chunk:
- IDs only: ~10 bytes per concept (int64 + overhead)
- Names: ~30 bytes avg per concept name
- Additional: ~100 bytes per chunk for concept_names

**Total increase:** ~50MB (acceptable for the query benefits)

---

## Impact on Codebase

### Caches Become Optional

With denormalized names stored in tables, ID-resolution caches are **no longer required** for queries:

| Cache | Current Role | New Role |
|-------|--------------|----------|
| `ConceptIdCache` | **Required** - resolve IDs to names at runtime | **Optional** - only for regeneration scripts |
| `CatalogSourceCache` | **Required** - resolve catalogId to source | **Optional** - catalog_titles provides this |
| `CategoryIdCache` | **Required** - resolve IDs to names | **Optional** - category_names provides this |

### Tool Changes

Tools should query on **names** not IDs:

```typescript
// BEFORE (requires cache initialization)
const conceptId = ConceptIdCache.getId('strategy pattern');
const chunks = await chunksTable.query()
  .where(`array_contains(concept_ids, ${conceptId})`)
  .toArray();

// AFTER (direct query on names)
const chunks = await chunksTable.query()
  .where(`array_contains(concept_names, 'strategy pattern')`)
  .toArray();
```

### Benefits

1. **Simpler startup** - no cache initialization required
2. **Better error messages** - human-readable names in queries
3. **Debuggable** - can inspect data directly in DB
4. **Text search** - partial matching on names (`LIKE '%strategy%'`)

---

## Open Questions

1. **Real-time vs batch derived updates?**
   - Current: Batch rebuild after seeding
   - Alternative: Update derived fields incrementally on each document add
   
2. **Should caches be removed entirely?**
   - Pro: Simpler codebase, no initialization
   - Con: Still useful for regeneration scripts and edge cases

---

## Complete Field Classification

### Summary Table

| Table | Field | Type | Classification | Regeneration Source |
|-------|-------|------|----------------|---------------------|
| **concepts** | `id` | number | CANONICAL | hash(name) |
| | `name` | string | CANONICAL | LLM extraction |
| | `summary` | string | CANONICAL | LLM generation |
| | `catalog_ids` | number[] | DERIVED | scan `catalog.concept_ids` |
| | `catalog_titles` | string[] | **DERIVED** ✨ | lookup from `catalog.source` (title) |
| | `chunk_ids` | number[] | DERIVED | scan `chunks.concept_ids` |
| | `adjacent_ids` | number[] | DERIVED | co-occurrence analysis |
| | `related_ids` | number[] | DERIVED | lexical matching |
| | `synonyms` | string[] | ENRICHED | WordNet |
| | `broader_terms` | string[] | ENRICHED | WordNet |
| | `narrower_terms` | string[] | ENRICHED | WordNet |
| | `weight` | number | DERIVED | frequency calculation |
| | `vector` | Float32[] | DERIVED | embed(name) |
| **catalog** | `id` | number | CANONICAL | hash(source) |
| | `source` | string | CANONICAL | file path |
| | `concept_ids` | number[] | CANONICAL | LLM extraction |
| | `concept_names` | string[] | DERIVED | lookup from `concepts.name` |
| | `category_ids` | number[] | CANONICAL | LLM extraction |
| | `summary` | string | CANONICAL | LLM generation |
| | `vector` | Float32[] | DERIVED | embed(summary) |
| **chunks** | `id` | number | CANONICAL | hash(source+index) |
| | `catalog_id` | number | CANONICAL | parent document |
| | `text` | string | CANONICAL | document content |
| | `concept_ids` | number[] | CANONICAL | concept matching |
| | `concept_names` | string[] | DERIVED | lookup from `concepts.name` |
| | `concept_density` | number | DERIVED | len(concept_ids)/text_len |
| | `vector` | Float32[] | DERIVED | embed(text) |
| **categories** | `id` | number | CANONICAL | hash(category) |
| | `category` | string | CANONICAL | LLM extraction |
| | all other fields | various | DERIVED/ENRICHED | various |

### Classification Key

- **CANONICAL**: Source of truth, populated during seeding
- **DERIVED**: Regenerated from canonical fields, can be rebuilt
- **ENRICHED**: External data source (WordNet, LLM summaries)

---

## Implementation Plan

### Phase 1: Domain Models ✅ (Done)
- [x] Add `conceptNames` to `Chunk` model
- [x] Add `conceptNames`, `categoryNames`, `categoryIds` to `SearchResult` model
- [x] Add `catalogTitles` to `Concept` model
- [x] Add `catalog_titles` to `ConceptRecord` type

### Phase 2: Repository Mapping ✅ (Done)
- [x] Update `lancedb-chunk-repository` to parse `concept_names`
- [x] Update `lancedb-concept-repository` to parse `catalog_titles`
- [x] Update `lancedb-catalog-repository` to parse `concept_names`, `category_names`
- [x] Add `conceptNames` to return object in `mapRowToChunk`

### Phase 3: Seeding ✅ (Done)
- [x] Update `hybrid_fast_seed.ts` to populate `concept_names` in chunks
- [x] Update `hybrid_fast_seed.ts` to populate `concept_names`, `category_names` in catalog
- [x] Update `concept_index.ts` to populate `catalog_titles` in concepts

### Phase 4: Regeneration Script ✅ (Done)
- [x] Create `scripts/rebuild_derived_names.ts`
  - Rebuild `chunks.concept_names` from `concept_ids` → `concepts.name`
  - Rebuild `catalog.concept_names` from `concept_ids` → `concepts.name`
  - Rebuild `catalog.category_names` from `category_ids` → `categories.category`
  - Rebuild `concepts.catalog_titles` from `catalog_ids` → `catalog.source`

### Phase 5: Tool Refactoring ✅ (Done)
- [x] Audit all tools that use `ConceptIdCache` for queries
- [x] Refactor to query on `concept_names` instead of resolving IDs
- [x] Audit all tools that use `CatalogSourceCache` for queries
- [x] Refactor to use `catalog_titles` or similar
- [x] Mark caches as optional (for regeneration only)

### Phase 6: Documentation ✅ (Done)
- [x] Update `docs/database-schema.md` with new derived fields
- [x] Document canonical vs derived field classification
- [x] Add regeneration instructions

### Phase 7: Migration & Testing ✅ (Done)
- [x] Test on `test_db` with sample docs
- [x] Run regeneration script (verified schema requirements)
- [x] Verify backward compatibility with cache fallback
- [x] Add test script: `scripts/test-backward-compat.ts`

**Note:** Existing databases with placeholder `concept_ids` need re-seeding to benefit from derived fields. The backward compatibility ensures tools work with both old and new databases.

---

## New Derived Fields Summary

| Table | New Field | Type | Regeneration Source |
|-------|-----------|------|---------------------|
| `chunks` | `concept_names` | `string[]` | `concept_ids` → `concepts.name` |
| `catalog` | `concept_names` | `string[]` | `concept_ids` → `concepts.name` |
| `catalog` | `category_names` | `string[]` | `category_ids` → `categories.category` |
| `concepts` | `catalog_titles` | `string[]` | `catalog_ids` → `catalog.source` |

---

## Related Files

- Current schema: `docs/database-schema.md`
- Seeding script: `hybrid_fast_seed.ts`
- Concept index builder: `src/concepts/concept_index.ts`
- ID cache: `src/infrastructure/cache/concept-id-cache.ts`

